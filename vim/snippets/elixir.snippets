snippet mm
	Map.${1:func}(${2:val}) ${3}
snippet mmm
	Map.${1:func} ${2:val}
snippet mk
	Map.keys(${1:map}) ${2}
snippet mkw
	Map.keys ${1:map}
snippet mhk
	Map.has_key?(${1:map}, ${2:key}) ${3}
snippet mhkw
	Map.has_key? ${1:map}, ${2:key}
snippet mg
	Map.get(${1:map}, ${2:key}) ${3}
snippet mgg
	Map.get ${1:map}, ${2:key}
snippet mp
	Map.put(${1:map}, ${2:key}, ${3:val}) ${4}
snippet mpp
	Map.put ${1:map}, ${2:key}, ${3:val}
snippet m
	%{${1}}${2}
snippet ma
	%{${1:key1}: ${2:val1}}
snippet mam
	%{${1:key1}: ${2:val1}, ${3:key2}: ${4:val2}}
snippet mamm
	%{${1:key1}: ${2:val1}, ${3:key2}: ${4:val2}, ${5:key3}: ${6:val3}}
snippet mc
	%{conn: conn${1}} ${2}
snippet mcu
	%{conn: conn, user: user${1}} ${2}
snippet j
	:${1:atom}
snippet jk
	${1:atom}: ${2:val}
snippet jkl
	${1:atom}: "${2:str}"
snippet kj
	"${1:str}": ${2:val}
snippet lkj
	"${1:str}": "${2:str}"
snippet sm
	%{"${1:key1}" => ${2:val1}}
snippet smm
	%{"${1:key1}" => ${2:val1}, "${3:key2}" => ${4:val2}}
snippet smmm
	%{"${1:key1}" => ${2:val1}, "${3:key2}" => ${4:val2}, "${5:key3}" => ${6:val3}}
snippet pl
	`:d`(${1})
snippet wl
	~w(${1})
snippet t
	{${1}}
snippet tt
	{:${1:ok}, ${2}}
snippet l
	[${1}]
snippet kl
	[${1:key}: ${2:val}]
snippet kll
	[${1:key}: ${2:val}, ${3:key}: ${4:val}]
snippet kkl
	${1:key}: ${2:val}
snippet kkll
	${1:key}: ${2:val}, ${3:key}: ${4:val}
snippet s
	"${1:str}"
snippet ss
	#{${1:str}}
snippet st
	%${1:Struct}{${2}}
snippet stt
	%${1:NS1}.${2:NS2}{${3}}
snippet if
	if ${1:condition} do
		${2}
	end
snippet d
	def ${1:name}(${2:params}) do
		${3}
	end
snippet dn
	def ${1:name} do
		${2}
	end
snippet di
	def ${1:name}(${2:params}), do: ${3}
snippet din
	def ${1:name}, do: ${2}
snippet dp
	defp ${1:name}(${2:params}) do
		${3}
	end
snippet dpi
	defp ${1:name}(${2:params}), do: ${3}
snippet da
	def ${1:action}(conn, ${2:params}) do
		${3}
	end
snippet daa
	def ${1:action}(conn, %{"${2:key}" => ${3:var}}) do
		${4}
	end
snippet mn
	`MixProjectName()`.${1}
snippet dm
	defmodule ${1:`MixProjectName()`} do
		${2}
	end
snippet dmm
	defmodule ${1:`MixProjectName()`}.${2:Module} do
		${3}
	end
snippet dpm
	defmodule `MixProjectName()`.${1:Module} do
		${2}
	end
snippet dpc
	defmodule `MixProjectName()`.${1:`GetPhoenixControllerName()`}Controller do
		use `MixProjectName()`.Web, :controller

		alias `MixProjectName()`.{Repo, `g:phoenix_cname`}

		plug :scrub_params, "${2:`g:phoenix_cname`}" when action in [:create, :update]

		def ${3:action}(conn, ${4:params}) do
			${5}
		end
	end
snippet p

	|> ${1}
snippet pp
	|> ${1}
snippet c
	case ${1:switch} do
		${2:case1} -> ${3:run1}
		_ -> ${4:pokemon}
	end
snippet cb
		${1:condition} -> ${2:branch}
snippet f
	fn(${1:params}) -> ${2} end
snippet fn
	fn ${1:params} -> ${2} end
snippet af
	&(${1})
snippet afn
	& ${1}
snippet ff
	fn(${1:params}) ->
		${2}
	end
snippet fc
	${1:func}(${2:params})
snippet ffc
	${1:Module}.${2:func}(${3:params})
snippet fffc
	${1:`MixProjectName()`}.${2:Module}.${3:func}(${4:params})
snippet al
	alias ${1:`MixProjectName()`}.${2:Module}
snippet all
	alias ${1:`MixProjectName()`}.{${2:Module}}
snippet alr
	alias `MixProjectName()`.{Repo}
	${1}
snippet alrm
	alias ${1:`MixProjectName()`}.{Repo, ${2:Module}}
snippet alru
	alias `MixProjectName()`.{Repo, User}
	${1}
snippet alrum
	alias ${1:`MixProjectName()`}.{Repo, User, ${2:Module}}
snippet im
	import ${1:`MixProjectName()`}.${2:Module}
snippet imef
	import Ecto.Query, only: [from: 2]
snippet imo
	import ${1:`MixProjectName()`}.${2:Module}, only: [${3:func}: ${4:arity}]
snippet u
	use ${1:`MixProjectName()`}.${2:Module}
snippet uu
	use ${1:`MixProjectName()`}.${2:Module}, :${3:func}
snippet uw
	use `MixProjectName()`.Web, :${1:func}
snippet uwc
	use `MixProjectName()`.Web, :controller
snippet uwm
	use `MixProjectName()`.Web, :model
snippet uwv
	use `MixProjectName()`.Web, :view
snippet ec
	Ecto.Changeset
snippet mec
	%Ecto.Changeset{${1:key}: ${2:val}}
# alias mec -> ecm
snippet ecm
	%Ecto.Changeset{${1:key}: ${2:val}}
snippet cs
	changeset
snippet pr
	IEx.pry
snippet prr
	require IEx; IEx.pry
snippet ar
	alias `MixProjectName()`.Repo
snippet am
	`AliasPhoenixModelsLike(input('Characters in model name: '))`
snippet ra
	Repo.all(${1:query})
snippet rd
	Repo.delete(${1:resource})
snippet rdd
	Repo.delete!(${1:resource})
snippet rg
	Repo.get(${1:query})
snippet rgg
	Repo.get!(${1:query})
snippet rgb
	Repo.get_by(${1:Model}, ${2:attr}: "${3:val}")
snippet rgbb
	Repo.get_by!(${1:Model}, ${2:attr}: "${3:val}")
snippet ro
	Repo.one(${1:query})
snippet roo
	Repo.one!(${1:query})
snippet ru
	Repo.update(${1:changeset})
snippet ruu
	Repo.update!(${1:changeset})
snippet sti
	String.to_integer(${1:str})
snippet stii
	String.to_integer(${1:str}, ${2:base_int})
snippet stf
	String.to_float(${1:str})
snippet stl
	String.to_char_list(${1:str})
snippet str
	String.${1:func}(${2:str}, ${3:arg})
snippet con
	cond do
		${1}
	end
snippet pfi

	|> put_flash(:info, "${1:info}")
snippet pfe

	|> put_flash(:error, "${1:error}")
snippet r

	|> render("${1:template}.${2:html}")
snippet rt

	|> redirect(to: "${1:/}")
snippet rtp

	|> redirect(to: ${1:user}_path(conn, :${2:action}))
snippet ts
	to_string ${1:val}
snippet tss
	to_string(${1:val})${2}
snippet mod
	__MODULE__
snippet i
	IO.puts ${1:val}
snippet iop
	IO.puts ${1:val}
snippet ios
	IO.inspect ${1:val}
snippet gs
	GenServer
snippet reply
	{:reply, ${1:resp}, ${2:socket}}
snippet nr
	{:noreply, ${1:socket}}
snippet e
	Enum.${1:map}(&${2})
snippet ei
	Enum.into(${1:%{}})${2}
snippet ee
	Enum.each(& ${1:IO}.${2:puts} ${3:&1})
snippet em
	Enum.map(& ${1:Foo}.${2:bar} ${3:&1})
snippet eee
	Enum.each(fn ${1:params} -> ${2:IO}.${3:puts} ${4:params} end)
snippet emm
	Enum.map(fn ${1:params} -> ${2:Foo}.${3:Bar} ${4:params} end)
snippet o
	:ok
snippet ot
	{:ok, ${1}}
snippet mr
	make_ref()
snippet red
	receive do
		${1:msg} -> ${2:foo}
	end
snippet hs
	def handle_cast(${1:msg}, ${2:val}) do
		{:noreply, ${3:val}}
	end
snippet hl
	def handle_call(${1:msg}, ${2:val}) do
		{:reply, ${3:val}, ${4:val}}
	end
snippet hi
	def handle_info(${1:msg}, ${2:val}) do
		{:noreply, ${3:val}}
	end
snippet ds
	defstruct [${1}]
snippet dpr
	defprotocol `MixProjectName()`.${1:Protocol} do
		def ${2:func}(${3:args}) do
			${4}
		end
	end
snippet dim
	defimpl `MixProjectName()`.${1:Protocol}, for: `MixProjectName()`.${2:Protocol} do
		def ${3:func}(${4:args}) do
			${5}
		end
	end
snippet	b
	@behaviour ${1:`MixProjectName()`}.${2:Module}
snippet doc
	@doc "${1:doc_text}"
snippet docc
	@doc """
	${1:doc_text}
	"""
snippet docs
	@doc ~S"""
	${1:doc_text}
	"""
snippet mdoc
	@moduledoc """
	${1:doc_text}
	"""
snippet re
	~r{${1:re}}
snippet sig
	~${1:s}{${2:foo}}
snippet sigo
	~${1:s}{${2:foo}}${3:o}
snippet stre
	Stream.${1:map}(&${2})
snippet w
	with {${1::ok}, ${2::val}} <- ${3:func}(${4:params}),
	do: ${5:func}(${6:val})
snippet cu
	current_user
snippet cuu
	conn.assigns.current_user
snippet hr
	=> ${1}
snippet ree
	Regex.${1:run}(~r{${2:re}}, ${3:str}) ${4}
snippet a
	-> ${1}
snippet -
	`ReplaceCurrentLineWithSnakeCase()`
snippet dpv
	defmodule ${1:`MixProjectName()`}.${2:Resource}View do
		use PhoenixTemplate.Web, :view ${3}
	end
snippet isn
	is_nil(${1:val})
snippet isb
	is_binary(${1:str})
snippet ism
	is_map(${1:map})
snippet isa
	is_atom(${1:atom})
snippet ist
	is_${1:type}(${2:val})
snippet ri
	raise inspect ${1:val}
snippet reqd
	@required_attrs ~i(${1:atom})
snippet reqdd
	@required_attrs [${1:atom}]
snippet req
	@required_attrs${1}
snippet optd
	@optional_attrs ~i(${1:atom})
snippet optdd
	@optional_attrs [${1:atom}]
snippet opt
	@optional_attrs${1}
snippet h
	<%= ${1} %>
snippet lc
	<.${1}/>
snippet lcc
	<.${1}>
		${3}
	</.${2}>
snippet sl
	<:${1}/>
snippet sll
	<:${1}>
		${3}
	</:${2}>
snippet ht
	<${1}/>
snippet htt
	<${1} ${3}>${4}</${2}>
snippet httt
	<${1} ${3}/>
	${4}
	</${2}>
snippet ps
	~p{${1}}
snippet he
	~H"""
	${1}
	"""
snippet tw
	@tag :wip
snippet sa
	socket.assigns.${1}
